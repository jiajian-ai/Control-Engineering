# PID控制器实验 - 使用说明

## 项目简介

本项目实现了一个完整的PID(比例-积分-微分)控制器，并通过4个详细的实验展示了Kp、Ki、Kd三个参数对系统控制性能的影响。所有实验结果都进行了完整的可视化。

## 快速开始

### 1. 安装依赖

```bash
pip install -r requirements.txt
```

需要的包:
- numpy (数值计算)
- matplotlib (绘图)

### 2. 运行实验

**方式一: 运行所有实验 (推荐)**
```bash
python run_all_demos.py
```

**方式二: 单独运行**
```bash
# 快速演示 (1个例子)
python quick_demo.py

# 完整实验 (4个详细实验)
python pid_experiments.py
```

### 3. 查看结果

实验会生成以下图片文件:
- `quick_demo.png` - 快速演示: 展示PID控制效果和目标值变化
- `experiment_1_kp_effect.png` - 实验1: Kp参数对系统的影响
- `experiment_2_ki_effect.png` - 实验2: Ki参数对系统的影响
- `experiment_3_kd_effect.png` - 实验3: Kd参数对系统的影响
- `experiment_4_combined_tuning.png` - 实验4: PID参数综合调节对比

详细的实验分析请查看 `实验报告.md`

## 项目文件说明

### 核心代码文件

#### 1. `pid_controller.py` - PID控制器实现
```python
from pid_controller import PIDController

# 创建PID控制器
pid = PIDController(Kp=2.0, Ki=0.5, Kd=0.1, setpoint=1.0)

# 在控制循环中使用
dt = 0.01  # 时间步长
current_output = 0.5  # 当前系统输出
control_signal = pid.update(current_output, dt)
```

**主要功能:**
- 完整的PID算法实现
- 支持设置输出限制
- 记录P、I、D各项历史数据
- 可动态修改目标值

#### 2. `simulated_system.py` - 模拟被控系统
```python
from simulated_system import FirstOrderSystem, SecondOrderSystem

# 一阶系统 (如温度控制)
system1 = FirstOrderSystem(tau=1.0)

# 二阶系统 (如机械系统)
system2 = SecondOrderSystem(mass=1.0, damping=0.5, stiffness=1.0)

# 更新系统
new_output = system1.update(control_input, dt)
```

**包含系统类型:**
- `FirstOrderSystem`: 一阶系统 (τ * dy/dt + y = u)
- `SecondOrderSystem`: 二阶系统 (m * d²y/dt² + c * dy/dt + k * y = u)
- `SystemWithNoise`: 带噪声的系统包装器

#### 3. `pid_experiments.py` - 完整实验代码
```python
from pid_experiments import PIDExperiments

experiments = PIDExperiments()

# 运行单个实验
experiments.experiment_kp_effect()  # Kp影响
experiments.experiment_ki_effect()  # Ki影响
experiments.experiment_kd_effect()  # Kd影响
experiments.experiment_combined_tuning()  # 综合调节

# 或运行所有实验
experiments.run_all_experiments()
```

**实验内容:**
- **实验1**: 测试5个不同的Kp值 (0.5, 1.0, 2.0, 5.0, 10.0)
- **实验2**: 测试5个不同的Ki值 (0.0, 0.5, 1.0, 2.0, 5.0)
- **实验3**: 测试5个不同的Kd值 (0.0, 0.5, 1.0, 2.0, 5.0)
- **实验4**: 对比5种控制策略 (P, PI, PD, 未调优PID, 优化PID)

### 辅助文件

- `quick_demo.py` - 快速演示脚本
- `run_all_demos.py` - 一键运行所有演示
- `README.md` - 英文项目说明
- `实验报告.md` - 详细实验报告
- `使用说明.md` - 本文件

## 实验结果预览

### 实验1: Kp参数影响

**观察要点:**
- Kp越大，系统响应越快
- Kp越大，稳态误差越小
- 但纯P控制无法完全消除稳态误差

### 实验2: Ki参数影响

**观察要点:**
- Ki能够消除稳态误差
- Ki越大，误差消除越快
- Ki过大会导致超调和振荡
- 积分项会逐渐累积

### 实验3: Kd参数影响

**观察要点:**
- Kd显著减小超调量
- Kd提供阻尼作用，抑制振荡
- Kd对噪声敏感
- 微分项在误差变化时最活跃

### 实验4: PID综合调节

**观察要点:**
- P控制: 快速但有稳态误差
- PI控制: 消除误差但超调大
- PD控制: 平稳但仍有误差
- 优化PID: 综合性能最佳

## PID参数调节指南

### 参数作用速查表

| 参数 | 增大效果 | 减小效果 | 推荐起始值 |
|------|---------|---------|-----------|
| Kp | 响应更快，误差更小，但可能振荡 | 响应变慢，误差增大，更平稳 | 1.0~5.0 |
| Ki | 消除稳态误差更快，但可能超调 | 误差消除慢，更稳定 | 0.1~2.0 |
| Kd | 超调更小，更稳定，但噪声敏感 | 超调增大，对噪声不敏感 | 0.1~1.0 |

### 调参步骤 (Ziegler-Nichols方法的简化版)

1. **设置初始值**: Kp=1, Ki=0, Kd=0
2. **调节Kp**: 
   - 逐渐增大Kp直到系统开始振荡
   - 记录临界Kp值
   - 将Kp设为临界值的50-70%
3. **加入Ki**:
   - 从小值开始 (如Kp/10)
   - 观察稳态误差是否消除
   - 如果超调过大则减小Ki
4. **加入Kd**:
   - 从小值开始 (如Kp/10)
   - 观察超调是否减小
   - 注意噪声影响
5. **微调优化**: 反复调整直到满意

### 常见问题及解决方案

| 问题 | 可能原因 | 解决方法 |
|------|---------|---------|
| 响应太慢 | Kp太小 | 增大Kp |
| 振荡不止 | Kp太大或Ki太大 | 减小Kp或Ki，增大Kd |
| 有稳态误差 | 没有积分项 | 加入Ki |
| 超调过大 | Ki太大或Kd太小 | 减小Ki，增大Kd |
| 对噪声敏感 | Kd太大 | 减小Kd或添加滤波 |
| 积分饱和 | Ki太大 | 减小Ki或实现抗饱和 |

## 性能指标说明

### 1. 上升时间 (Rise Time)
从0上升到目标值90%所需的时间
- 越短越好 (响应快)
- 通过增大Kp可以减小

### 2. 调节时间 (Settling Time)
系统进入并保持在目标值±2%误差带内所需的时间
- 越短越好 (稳定快)
- 通过增大Kd可以减小

### 3. 超调量 (Overshoot)
系统响应超过目标值的最大百分比
- 越小越好 (平稳)
- 通过增大Kd或减小Ki可以减小

### 4. 稳态误差 (Steady-State Error)
系统稳定后与目标值之间的误差
- 越小越好 (精确)
- 通过增大Ki可以消除

## 自定义实验

你可以修改实验代码来测试自己的参数:

```python
from pid_controller import PIDController
from simulated_system import FirstOrderSystem
import matplotlib.pyplot as plt
import numpy as np

# 仿真参数
dt = 0.01
time_steps = 2000
time = np.arange(0, time_steps * dt, dt)

# 创建系统和控制器
system = FirstOrderSystem(tau=1.0)
pid = PIDController(
    Kp=2.0,   # 修改这里
    Ki=0.5,   # 修改这里
    Kd=0.1,   # 修改这里
    setpoint=1.0
)

# 运行仿真
outputs = []
for t in time:
    current_output = system.state
    control = pid.update(current_output, dt)
    new_output = system.update(control, dt)
    outputs.append(new_output)

# 绘制结果
plt.plot(time, outputs, label='系统输出')
plt.axhline(y=1.0, color='r', linestyle='--', label='目标值')
plt.xlabel('时间 (s)')
plt.ylabel('输出')
plt.title(f'PID控制 (Kp={pid.Kp}, Ki={pid.Ki}, Kd={pid.Kd})')
plt.legend()
plt.grid(True)
plt.savefig('my_experiment.png')
plt.show()
```

## 扩展建议

### 初学者
1. 先运行 `quick_demo.py` 了解基本效果
2. 阅读 `实验报告.md` 理解原理
3. 尝试修改 `quick_demo.py` 中的PID参数
4. 观察参数变化对结果的影响

### 进阶使用
1. 修改 `pid_experiments.py` 中的参数范围
2. 测试不同的系统参数 (tau, mass, damping等)
3. 添加更复杂的扰动
4. 实现抗积分饱和 (anti-windup)
5. 添加前馈控制

### 高级应用
1. 实现自适应PID
2. 实现模糊PID
3. 实现神经网络PID
4. 连接实际硬件进行测试
5. 实现多变量PID控制

## 技术支持

如果遇到问题:
1. 检查Python版本 (推荐3.7+)
2. 确认依赖包已正确安装
3. 查看终端输出的错误信息
4. 参考 `README.md` 和 `实验报告.md`

## 许可证

本项目仅供学习和研究使用。

## 致谢

感谢使用本PID控制器实验项目！希望这些实验能帮助您深入理解PID控制原理。

---

**最后更新**: 2025年10月29日

