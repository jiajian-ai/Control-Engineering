# 第7章 仿真工具与实验平台

> **课程大纲导航**: [返回课程大纲](../CONTROL_ENGINEERING_OUTLINE.md) | [上一章：典型工程案例](第6章_典型工程案例分析.md)

---

## 📚 本章概述

控制系统的设计与验证离不开仿真工具和实验平台。本章将系统介绍控制工程中常用的仿真工具，重点讲解**MATLAB/Simulink**和**Python控制仿真库**的使用方法，并介绍虚拟仿真环境和硬件实验平台的搭建与应用。

**本章学习目标**：
1. 掌握MATLAB/Simulink的基本操作和控制系统建模方法
2. 熟练使用Python控制仿真库进行系统分析和控制器设计
3. 了解虚拟仿真环境的搭建和配置
4. 认识硬件实验平台的组成和应用场景
5. 学会选择合适的仿真工具解决实际控制问题

**为什么需要仿真工具？**

实际控制系统开发的挑战：
- ❌ **成本高昂**：硬件设备和实验成本
- ❌ **风险较大**：系统失稳可能损坏设备
- ❌ **调试困难**：参数调节耗时且危险
- ❌ **重现性差**：实验条件难以完全一致

仿真工具的优势：
- ✅ **低成本验证**：软件仿真成本极低
- ✅ **安全可靠**：无物理损坏风险
- ✅ **快速迭代**：参数调节方便快捷
- ✅ **完美重现**：实验条件完全可控
- ✅ **深入分析**：可观测所有内部状态

---

## 7.1 MATLAB/Simulink基础介绍

### 7.1.1 MATLAB/Simulink概述

#### 什么是MATLAB？

**MATLAB**（Matrix Laboratory）是MathWorks公司开发的数值计算和编程环境，在控制工程领域应用极为广泛。

**核心特点**：
- 🔢 **矩阵运算**：天然支持矩阵和向量运算
- 📊 **可视化**：强大的绘图和数据可视化功能
- 🧮 **工具箱**：丰富的专业工具箱（Control System Toolbox等）
- 🔗 **集成环境**：编程、仿真、分析一体化

#### 什么是Simulink？

**Simulink**是MATLAB的图形化仿真环境，特别适合动态系统建模和仿真。

**核心优势**：
- 🎯 **图形化建模**：拖拽式系统搭建
- ⚡ **实时仿真**：支持实时和加速仿真
- 🔧 **代码生成**：自动生成C/C++代码
- 🎛️ **硬件接口**：支持硬件在环仿真

### 7.1.2 MATLAB控制系统工具箱

#### 基本系统表示

```matlab
% 1. 传递函数表示
s = tf('s');                    % 定义拉普拉斯算子
G = 1/(s^2 + 2*s + 1);         % 二阶系统
H = 5*(s+1)/(s^2+3*s+2);       % 带零点的系统

% 2. 状态空间表示
A = [0 1; -2 -3];              % 系统矩阵
B = [0; 1];                    % 输入矩阵
C = [1 0];                     % 输出矩阵
D = 0;                         % 直通矩阵
sys_ss = ss(A, B, C, D);       % 状态空间模型

% 3. 零极点表示
z = [];                        % 零点
p = [-1, -2];                  % 极点
k = 5;                         % 增益
sys_zpk = zpk(z, p, k);        % 零极点模型
```

#### 系统分析功能

```matlab
% 时域分析
step(G);                       % 阶跃响应
impulse(G);                    % 脉冲响应
lsim(G, u, t);                % 任意输入响应

% 频域分析
bode(G);                       % 伯德图
nyquist(G);                    % 奈奎斯特图
rlocus(G);                     % 根轨迹

% 稳定性分析
pole(G);                       % 系统极点
isstable(G);                   % 稳定性判断
margin(G);                     % 稳定裕度
```

#### PID控制器设计

```matlab
% 自动PID调节
G = tf(1, [1 2 1]);           % 被控对象
C = pidtune(G, 'PID');        % 自动调节PID参数

% 手动PID设计
Kp = 10; Ki = 5; Kd = 2;
C_manual = pid(Kp, Ki, Kd);   % 手动设置PID参数

% 闭环系统分析
T = feedback(C*G, 1);         % 闭环传递函数
step(T);                      % 闭环阶跃响应
stepinfo(T);                  % 性能指标
```

### 7.1.3 Simulink建模基础

#### 基本建模流程

**1. 创建新模型**
```matlab
% 命令行创建
new_system('my_control_system');
open_system('my_control_system');
```

**2. 添加基本模块**

常用模块库：
- **Sources**：信号源（Step、Sine Wave、Constant等）
- **Sinks**：输出（Scope、To Workspace等）
- **Continuous**：连续系统（Transfer Fcn、State-Space等）
- **Math Operations**：数学运算（Sum、Gain、Product等）

**3. 连接和配置**
- 拖拽连线连接模块
- 双击模块设置参数
- 设置仿真参数（时间、求解器等）

#### 典型控制系统建模

**闭环控制系统结构**：
```
Reference → [Sum] → [Controller] → [Plant] → Output
    ↑         ↑                              ↓
    │         └──────── [Sensor] ←───────────┘
    │
    └─ Setpoint
```

**Simulink实现步骤**：
1. 添加Step模块作为参考输入
2. 添加Sum模块计算误差
3. 添加PID Controller模块
4. 添加Transfer Fcn模块表示被控对象
5. 添加Scope模块观察输出
6. 连接各模块形成闭环

#### 仿真配置与运行

```matlab
% 设置仿真参数
set_param('my_control_system', 'StopTime', '10');     % 仿真时间
set_param('my_control_system', 'Solver', 'ode45');   % 求解器

% 运行仿真
sim('my_control_system');

% 获取仿真结果
simout = sim('my_control_system');
output_data = simout.get('output_signal');
```

---

## 7.2 Python控制仿真库

### 7.2.1 Python控制生态系统

#### 核心库介绍

**1. NumPy - 数值计算基础**
```python
import numpy as np

# 矩阵运算
A = np.array([[0, 1], [-2, -3]])
B = np.array([[0], [1]])
eigenvals = np.linalg.eigvals(A)  # 特征值计算
```

**2. SciPy - 科学计算**
```python
from scipy import signal
from scipy.integrate import odeint

# 信号处理和系统分析
num = [1]
den = [1, 2, 1]
sys = signal.TransferFunction(num, den)
t, y = signal.step(sys)  # 阶跃响应
```

**3. Matplotlib - 数据可视化**
```python
import matplotlib.pyplot as plt

# 绘制系统响应
plt.figure(figsize=(10, 6))
plt.plot(t, y, 'b-', linewidth=2, label='Step Response')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('System Step Response')
plt.grid(True)
plt.legend()
plt.show()
```

**4. Control - 控制系统专用库**
```python
import control as ct

# 控制系统分析
G = ct.tf([1], [1, 2, 1])        # 传递函数
t, y = ct.step_response(G)       # 阶跃响应
ct.bode_plot(G)                  # 伯德图
ct.root_locus(G)                 # 根轨迹
```

### 7.2.2 基于Python的控制系统分析

#### 系统建模与表示

```python
import numpy as np
import control as ct
import matplotlib.pyplot as plt

# 1. 传递函数建模
def create_transfer_function():
    """创建传递函数模型"""
    # 二阶系统: G(s) = 1/(s^2 + 2ζωn*s + ωn^2)
    wn = 2.0      # 自然频率
    zeta = 0.5    # 阻尼比
    
    num = [wn**2]
    den = [1, 2*zeta*wn, wn**2]
    G = ct.tf(num, den)
    
    print(f"传递函数: {G}")
    return G

# 2. 状态空间建模
def create_state_space():
    """创建状态空间模型"""
    # 倒立摆系统线性化模型
    A = np.array([[0, 1, 0, 0],
                  [0, 0, -10.78, 0],
                  [0, 0, 0, 1],
                  [0, 0, 21.56, 0]])
    
    B = np.array([[0], [1.0], [0], [-1.0]])
    C = np.array([[1, 0, 0, 0],
                  [0, 0, 1, 0]])
    D = np.zeros((2, 1))
    
    sys = ct.ss(A, B, C, D)
    print(f"状态空间模型维度: {sys.nstates}状态, {sys.ninputs}输入, {sys.noutputs}输出")
    return sys
```

#### 时域分析

```python
def time_domain_analysis(G):
    """时域分析函数"""
    plt.figure(figsize=(15, 10))
    
    # 1. 阶跃响应
    plt.subplot(2, 3, 1)
    t_step, y_step = ct.step_response(G, T=np.linspace(0, 10, 1000))
    plt.plot(t_step, y_step, 'b-', linewidth=2)
    plt.title('阶跃响应 (Step Response)')
    plt.xlabel('时间 (s)')
    plt.ylabel('幅值')
    plt.grid(True)
    
    # 2. 脉冲响应
    plt.subplot(2, 3, 2)
    t_impulse, y_impulse = ct.impulse_response(G, T=np.linspace(0, 10, 1000))
    plt.plot(t_impulse, y_impulse, 'r-', linewidth=2)
    plt.title('脉冲响应 (Impulse Response)')
    plt.xlabel('时间 (s)')
    plt.ylabel('幅值')
    plt.grid(True)
    
    # 3. 正弦输入响应
    plt.subplot(2, 3, 3)
    t = np.linspace(0, 10, 1000)
    u = np.sin(2*np.pi*0.5*t)  # 0.5Hz正弦波
    t_sim, y_sim = ct.forced_response(G, T=t, U=u)
    plt.plot(t_sim, u, 'g--', label='输入', alpha=0.7)
    plt.plot(t_sim, y_sim, 'b-', label='输出', linewidth=2)
    plt.title('正弦输入响应')
    plt.xlabel('时间 (s)')
    plt.ylabel('幅值')
    plt.legend()
    plt.grid(True)
    
    # 4. 性能指标计算
    step_info = ct.step_info(G)
    plt.subplot(2, 3, 4)
    plt.text(0.1, 0.8, f"上升时间: {step_info['RiseTime']:.3f}s", transform=plt.gca().transAxes)
    plt.text(0.1, 0.7, f"峰值时间: {step_info['PeakTime']:.3f}s", transform=plt.gca().transAxes)
    plt.text(0.1, 0.6, f"超调量: {step_info['Overshoot']:.1f}%", transform=plt.gca().transAxes)
    plt.text(0.1, 0.5, f"调节时间: {step_info['SettlingTime']:.3f}s", transform=plt.gca().transAxes)
    plt.title('性能指标')
    plt.axis('off')
    
    plt.tight_layout()
    plt.show()
```

#### 频域分析

```python
def frequency_domain_analysis(G):
    """频域分析函数"""
    plt.figure(figsize=(15, 5))
    
    # 1. 伯德图
    plt.subplot(1, 3, 1)
    mag, phase, omega = ct.bode_plot(G, dB=True, Hz=False, plot=False)
    
    plt.subplot(2, 3, 1)
    plt.semilogx(omega, 20*np.log10(mag))
    plt.title('幅频特性')
    plt.xlabel('频率 (rad/s)')
    plt.ylabel('幅值 (dB)')
    plt.grid(True)
    
    plt.subplot(2, 3, 4)
    plt.semilogx(omega, np.degrees(phase))
    plt.title('相频特性')
    plt.xlabel('频率 (rad/s)')
    plt.ylabel('相位 (度)')
    plt.grid(True)
    
    # 2. 奈奎斯特图
    plt.subplot(1, 3, 2)
    real, imag, omega = ct.nyquist_plot(G, plot=False)
    plt.plot(real, imag, 'b-', linewidth=2)
    plt.title('奈奎斯特图')
    plt.xlabel('实部')
    plt.ylabel('虚部')
    plt.grid(True)
    plt.axis('equal')
    
    # 3. 根轨迹
    plt.subplot(1, 3, 3)
    rlist, klist = ct.root_locus(G, plot=False)
    plt.plot(rlist.real, rlist.imag, 'b-', linewidth=1)
    plt.title('根轨迹')
    plt.xlabel('实部')
    plt.ylabel('虚部')
    plt.grid(True)
    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    
    plt.tight_layout()
    plt.show()
```

### 7.2.3 项目中的Python仿真实现

基于我们项目中的实际代码，让我们看看如何实现完整的控制系统仿真：

#### PID控制器仿真

```python
# 基于项目中的PIDController类
from PIDController.pid_controller import PIDController
from PIDController.simulated_system import SimulatedSystem
import numpy as np
import matplotlib.pyplot as plt

def pid_simulation_demo():
    """PID控制仿真演示"""
    # 创建被控系统（二阶系统）
    system = SimulatedSystem(
        transfer_function_num=[1.0],
        transfer_function_den=[1.0, 0.5, 1.0],
        dt=0.01
    )
    
    # 创建PID控制器
    pid = PIDController(Kp=2.0, Ki=1.0, Kd=0.5, setpoint=1.0)
    pid.set_output_limits(-10, 10)
    
    # 仿真参数
    simulation_time = 10.0
    dt = 0.01
    time_steps = int(simulation_time / dt)
    
    # 存储仿真数据
    time_array = np.linspace(0, simulation_time, time_steps)
    setpoint_array = np.ones(time_steps)
    output_array = np.zeros(time_steps)
    control_array = np.zeros(time_steps)
    
    # 仿真循环
    current_output = 0.0
    for i in range(time_steps):
        # PID控制计算
        control_signal = pid.update(current_output, dt)
        
        # 系统响应
        current_output = system.update(control_signal)
        
        # 记录数据
        output_array[i] = current_output
        control_array[i] = control_signal
    
    # 绘制结果
    plt.figure(figsize=(12, 8))
    
    plt.subplot(2, 1, 1)
    plt.plot(time_array, setpoint_array, 'r--', label='设定值', linewidth=2)
    plt.plot(time_array, output_array, 'b-', label='系统输出', linewidth=2)
    plt.title('PID控制系统响应')
    plt.xlabel('时间 (s)')
    plt.ylabel('输出')
    plt.legend()
    plt.grid(True)
    
    plt.subplot(2, 1, 2)
    plt.plot(time_array, control_array, 'g-', label='控制信号', linewidth=2)
    plt.title('控制信号')
    plt.xlabel('时间 (s)')
    plt.ylabel('控制量')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    return time_array, output_array, control_array
```

#### MPC控制器仿真

```python
# 基于项目中的MPCController类
from MPCController.mpc_controller import MPCController, cartpole_dynamics
import numpy as np
import matplotlib.pyplot as plt

def mpc_simulation_demo():
    """MPC控制仿真演示"""
    # 创建MPC控制器
    mpc = MPCController(
        prediction_horizon=10,
        control_horizon=5,
        dt=0.02,
        Q=np.diag([10, 1, 100, 10]),  # 状态权重
        R=np.array([[0.1]]),          # 控制权重
        u_min=-50,
        u_max=50
    )
    
    # 设置目标状态 [位置, 速度, 角度, 角速度]
    mpc.set_target(np.array([0.0, 0.0, 0.0, 0.0]))
    
    # 仿真参数
    simulation_time = 5.0
    dt = 0.02
    time_steps = int(simulation_time / dt)
    
    # 初始状态（倒立摆稍微偏离平衡位置）
    current_state = np.array([0.0, 0.0, 0.2, 0.0])
    
    # 存储仿真数据
    time_array = np.linspace(0, simulation_time, time_steps)
    state_history = np.zeros((time_steps, 4))
    control_history = np.zeros(time_steps)
    
    # 仿真循环
    for i in range(time_steps):
        # MPC优化求解
        optimal_control = mpc.update(current_state, cartpole_dynamics)
        
        # 应用控制并更新状态
        current_state = cartpole_dynamics(current_state, optimal_control, dt)
        
        # 记录数据
        state_history[i] = current_state
        control_history[i] = optimal_control
    
    # 绘制结果
    plt.figure(figsize=(15, 10))
    
    # 状态变量
    state_labels = ['位置 (m)', '速度 (m/s)', '角度 (rad)', '角速度 (rad/s)']
    for i in range(4):
        plt.subplot(3, 2, i+1)
        plt.plot(time_array, state_history[:, i], 'b-', linewidth=2)
        plt.axhline(y=0, color='r', linestyle='--', alpha=0.7)
        plt.title(f'状态 {i+1}: {state_labels[i]}')
        plt.xlabel('时间 (s)')
        plt.ylabel(state_labels[i])
        plt.grid(True)
    
    # 控制信号
    plt.subplot(3, 2, 5)
    plt.plot(time_array, control_history, 'g-', linewidth=2)
    plt.title('控制力 (N)')
    plt.xlabel('时间 (s)')
    plt.ylabel('力 (N)')
    plt.grid(True)
    
    # 相平面图（角度-角速度）
    plt.subplot(3, 2, 6)
    plt.plot(state_history[:, 2], state_history[:, 3], 'b-', linewidth=2)
    plt.plot(state_history[0, 2], state_history[0, 3], 'go', markersize=8, label='起点')
    plt.plot(0, 0, 'ro', markersize=8, label='目标')
    plt.title('相平面图 (角度-角速度)')
    plt.xlabel('角度 (rad)')
    plt.ylabel('角速度 (rad/s)')
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    return time_array, state_history, control_history
```

---

## 7.3 实验平台（虚拟仿真+硬件平台简述）

### 7.3.1 虚拟仿真环境

#### 仿真环境的优势

**成本效益**：
- 💰 **零硬件成本**：无需购买昂贵设备
- ⚡ **快速迭代**：算法修改立即生效
- 🔄 **无限重复**：实验可完美重现

**安全可靠**：
- 🛡️ **无物理风险**：不会损坏设备
- 🎯 **极限测试**：可测试危险工况
- 📊 **完整观测**：所有状态变量可见

#### 常用虚拟仿真平台

**1. MATLAB/Simulink仿真环境**

```matlab
% Simulink模型配置
model_name = 'control_system_sim';

% 设置仿真参数
set_param(model_name, 'Solver', 'ode45');
set_param(model_name, 'StopTime', '10');
set_param(model_name, 'RelTol', '1e-6');

% 运行仿真
simOut = sim(model_name);

% 分析结果
output_data = simOut.get('output');
plot(output_data.Time, output_data.Data);
```

**2. Python仿真环境**

```python
class VirtualControlLab:
    """虚拟控制实验室"""
    
    def __init__(self):
        self.systems = {}
        self.controllers = {}
        self.experiments = []
    
    def add_system(self, name, system_model):
        """添加被控系统"""
        self.systems[name] = system_model
    
    def add_controller(self, name, controller):
        """添加控制器"""
        self.controllers[name] = controller
    
    def run_experiment(self, system_name, controller_name, 
                      simulation_time=10.0, dt=0.01):
        """运行控制实验"""
        system = self.systems[system_name]
        controller = self.controllers[controller_name]
        
        # 仿真循环
        time_steps = int(simulation_time / dt)
        results = {
            'time': np.linspace(0, simulation_time, time_steps),
            'output': np.zeros(time_steps),
            'control': np.zeros(time_steps),
            'setpoint': np.ones(time_steps)
        }
        
        current_output = 0.0
        for i in range(time_steps):
            control_signal = controller.update(current_output, dt)
            current_output = system.update(control_signal)
            
            results['output'][i] = current_output
            results['control'][i] = control_signal
        
        self.experiments.append({
            'system': system_name,
            'controller': controller_name,
            'results': results
        })
        
        return results
    
    def compare_controllers(self, system_name, controller_list):
        """比较不同控制器性能"""
        plt.figure(figsize=(12, 8))
        
        for i, controller_name in enumerate(controller_list):
            results = self.run_experiment(system_name, controller_name)
            
            plt.subplot(2, 1, 1)
            plt.plot(results['time'], results['output'], 
                    label=f'{controller_name}', linewidth=2)
            
            plt.subplot(2, 1, 2)
            plt.plot(results['time'], results['control'], 
                    label=f'{controller_name}', linewidth=2)
        
        plt.subplot(2, 1, 1)
        plt.plot(results['time'], results['setpoint'], 
                'r--', label='设定值', alpha=0.7)
        plt.title('系统输出比较')
        plt.ylabel('输出')
        plt.legend()
        plt.grid(True)
        
        plt.subplot(2, 1, 2)
        plt.title('控制信号比较')
        plt.xlabel('时间 (s)')
        plt.ylabel('控制量')
        plt.legend()
        plt.grid(True)
        
        plt.tight_layout()
        plt.show()
```

**3. 基于Web的仿真平台**

现代Web技术使得在线仿真成为可能：

```javascript
// 使用JavaScript实现简单的PID仿真
class WebPIDSimulator {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.pid = new PIDController(1.0, 0.1, 0.05);
        this.system = new SecondOrderSystem(1.0, 0.5, 1.0);
        this.isRunning = false;
    }
    
    start() {
        this.isRunning = true;
        this.simulate();
    }
    
    simulate() {
        if (!this.isRunning) return;
        
        // 仿真步骤
        const control = this.pid.update(this.system.output, 0.01);
        this.system.update(control);
        
        // 绘制结果
        this.draw();
        
        // 继续仿真
        requestAnimationFrame(() => this.simulate());
    }
    
    draw() {
        // 清除画布并绘制仿真结果
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // ... 绘制代码
    }
}
```

#### 虚拟仿真的局限性

**模型精度限制**：
- ❌ **简化假设**：实际系统更复杂
- ❌ **参数不确定**：模型参数可能不准确
- ❌ **非线性忽略**：线性化模型的局限

**缺乏真实感**：
- ❌ **无物理约束**：理想化的执行器
- ❌ **无噪声干扰**：实际系统存在各种干扰
- ❌ **无硬件限制**：计算资源"无限"

### 7.3.2 硬件实验平台

#### 典型硬件平台组成

**1. 传感器系统**
- 🌡️ **温度传感器**：热电偶、RTD、热敏电阻
- 📏 **位置传感器**：编码器、电位器、LVDT
- ⚡ **速度传感器**：测速发电机、霍尔传感器
- 📐 **角度传感器**：陀螺仪、加速度计、磁编码器

**2. 执行器系统**
- 🔧 **电机驱动**：直流电机、步进电机、伺服电机
- 🌡️ **加热/制冷**：电阻加热器、半导体制冷器
- 💨 **气动系统**：气缸、比例阀、压力调节器
- 💧 **液压系统**：液压缸、伺服阀、泵站

**3. 控制器硬件**
- 💻 **工控机**：高性能实时控制
- 🔌 **PLC**：可编程逻辑控制器
- 🎛️ **单片机**：Arduino、STM32、树莓派
- 📡 **DSP**：数字信号处理器

#### 常见实验平台介绍

**1. 倒立摆实验平台**

```python
# 倒立摆硬件接口示例
class InvertedPendulumHardware:
    """倒立摆硬件接口类"""
    
    def __init__(self, serial_port='/dev/ttyUSB0'):
        self.serial_port = serial_port
        self.encoder_resolution = 4096  # 编码器分辨率
        self.motor_max_voltage = 12.0   # 电机最大电压
        
    def read_sensors(self):
        """读取传感器数据"""
        # 读取位置编码器
        cart_position = self.read_encoder('cart')
        pendulum_angle = self.read_encoder('pendulum')
        
        # 计算速度（数值微分）
        cart_velocity = self.calculate_velocity('cart')
        pendulum_velocity = self.calculate_velocity('pendulum')
        
        return np.array([cart_position, cart_velocity, 
                        pendulum_angle, pendulum_velocity])
    
    def send_control(self, control_voltage):
        """发送控制信号"""
        # 限制控制电压
        control_voltage = np.clip(control_voltage, 
                                -self.motor_max_voltage, 
                                 self.motor_max_voltage)
        
        # 发送到硬件
        self.write_dac(control_voltage)
    
    def emergency_stop(self):
        """紧急停止"""
        self.send_control(0.0)
        print("紧急停止！系统已安全停机。")
```

**2. 温度控制实验平台**

```python
class TemperatureControlHardware:
    """温度控制硬件接口"""
    
    def __init__(self):
        self.heater_power_max = 100.0  # 最大加热功率(W)
        self.temperature_range = (0, 100)  # 温度范围(°C)
        
    def read_temperature(self):
        """读取温度传感器"""
        # 从ADC读取热电偶信号
        adc_value = self.read_adc_channel(0)
        temperature = self.convert_adc_to_temperature(adc_value)
        return temperature
    
    def set_heater_power(self, power_percent):
        """设置加热器功率"""
        power_percent = np.clip(power_percent, 0, 100)
        pwm_duty = power_percent / 100.0
        self.set_pwm_output(pwm_duty)
    
    def safety_check(self, temperature):
        """安全检查"""
        if temperature > 80.0:  # 过温保护
            self.set_heater_power(0)
            raise Exception(f"温度过高: {temperature}°C")
```

#### 硬件在环仿真（HIL）

**概念介绍**：
硬件在环仿真结合了仿真的灵活性和硬件的真实性，部分系统用硬件实现，部分用软件仿真。

**典型应用**：
```python
class HILSimulation:
    """硬件在环仿真系统"""
    
    def __init__(self, real_hardware, virtual_plant):
        self.hardware = real_hardware      # 真实控制器硬件
        self.plant_sim = virtual_plant     # 虚拟被控对象
        self.interface = HILInterface()    # HIL接口
        
    def run_hil_test(self, test_duration=60.0):
        """运行HIL测试"""
        dt = 0.001  # 1ms采样周期
        steps = int(test_duration / dt)
        
        for i in range(steps):
            # 1. 从硬件控制器读取控制信号
            control_signal = self.hardware.read_control_output()
            
            # 2. 将控制信号输入虚拟被控对象
            plant_output = self.plant_sim.update(control_signal, dt)
            
            # 3. 将被控对象输出反馈给硬件控制器
            self.hardware.write_sensor_feedback(plant_output)
            
            # 4. 实时同步
            self.interface.wait_for_next_cycle()
        
        print("HIL测试完成")
```

#### 实验安全与注意事项

**安全措施**：
1. **紧急停止**：所有实验平台必须有紧急停止按钮
2. **限位保护**：机械限位和软件限位双重保护
3. **过载保护**：电流、电压、温度等参数监控
4. **故障诊断**：实时监测系统状态

**实验规范**：
```python
class ExperimentSafety:
    """实验安全管理"""
    
    def __init__(self):
        self.safety_limits = {
            'max_voltage': 24.0,
            'max_current': 5.0,
            'max_temperature': 80.0,
            'max_position': 0.5,
            'max_velocity': 2.0
        }
        
    def check_safety(self, system_state):
        """安全检查"""
        for param, limit in self.safety_limits.items():
            if abs(system_state.get(param, 0)) > limit:
                self.emergency_stop()
                raise SafetyException(f"{param}超出安全限制: {limit}")
    
    def emergency_stop(self):
        """紧急停止程序"""
        # 切断所有执行器电源
        # 记录故障日志
        # 发送报警信号
        pass
```

---

## 7.4 仿真工具选择指南

### 7.4.1 工具对比分析

| 特性 | MATLAB/Simulink | Python | 硬件平台 |
|------|----------------|---------|----------|
| **学习成本** | 中等 | 较低 | 较高 |
| **开发效率** | 高 | 高 | 中等 |
| **成本** | 高（商业软件） | 低（开源） | 高 |
| **可扩展性** | 中等 | 高 | 低 |
| **工业应用** | 广泛 | 增长中 | 必需 |
| **实时性能** | 好 | 中等 | 优秀 |

### 7.4.2 选择建议

**学术研究**：
- 🎓 **理论验证**：Python + Jupyter Notebook
- 📊 **快速原型**：MATLAB/Simulink
- 📝 **论文发表**：Python（开源可重现）

**工程应用**：
- 🏭 **工业控制**：MATLAB + 硬件平台
- 🚗 **嵌入式系统**：C/C++ + 硬件
- 🌐 **物联网**：Python + 树莓派

**教学培训**：
- 👨‍🎓 **本科教学**：MATLAB/Simulink（直观）
- 👨‍💻 **研究生课程**：Python（灵活）
- 🔧 **工程培训**：硬件平台（实践）

---

## 📝 本章小结

### 核心要点回顾

1. **MATLAB/Simulink**：
   - 控制工程的经典工具
   - 图形化建模直观易用
   - 丰富的工具箱支持
   - 工业界广泛应用

2. **Python控制仿真**：
   - 开源免费，生态丰富
   - 编程灵活，可扩展性强
   - 适合算法研究和原型开发
   - 与机器学习结合紧密

3. **虚拟仿真环境**：
   - 成本低，安全性高
   - 快速迭代，完美重现
   - 模型精度有限
   - 缺乏真实物理约束

4. **硬件实验平台**：
   - 真实物理系统
   - 验证实际性能
   - 成本高，风险大
   - 工程应用必需

### 实践建议

**初学者路径**：
1. 从MATLAB/Simulink开始，建立直观认识
2. 学习Python控制库，提高编程能力
3. 尝试简单硬件实验，积累实践经验

**进阶发展**：
1. 深入学习优化算法和数值方法
2. 掌握实时系统和嵌入式开发
3. 了解工业通信协议和标准

**项目实践**：
1. 选择合适的工具组合
2. 从仿真验证开始
3. 逐步过渡到硬件实现
4. 重视安全和可靠性

### 展望未来

**技术趋势**：
- 🤖 **数字孪生**：虚实结合的仿真
- ☁️ **云端仿真**：分布式计算资源
- 🧠 **AI辅助设计**：智能化工具
- 🌐 **协同仿真**：多学科集成

控制工程的仿真工具将继续发展，但基本原理和方法论将保持稳定。掌握多种工具的使用，培养系统性思维，是控制工程师的核心竞争力。

---

> **下一步学习**：
> - 实践项目中的仿真代码
> - 尝试不同工具的组合使用
> - 关注最新的仿真技术发展
> - 参与开源项目贡献代码

> **相关资源**：
> - [项目代码库](../)
> - [MATLAB官方文档](https://www.mathworks.com/help/control/)
> - [Python Control库文档](https://python-control.readthedocs.io/)
> - [控制工程在线课程](https://www.coursera.org/learn/control-of-mobile-robots)