# 第6章 典型工程案例分析

> **课程大纲导航**: [返回课程大纲](../CONTROL_ENGINEERING_OUTLINE.md) | [上一章：先进控制方法](第5章_先进控制方法入门.md)

---

## 📚 本章概述

本章基于项目中的实际实现，深入分析两个典型控制案例：**房间温度控制**（一阶系统）和**CartPole倒立摆**（高阶非线性系统）。通过对比PID、MPC和强化学习在不同场景下的表现，帮助理解各种控制方法的适用范围和工程权衡。

**本章学习目标**：
1. 掌握一阶系统（温度控制）的建模、控制器设计与调试
2. 理解高阶非线性系统（CartPole）的复杂性与控制挑战
3. 对比PID、MPC、RL在不同系统上的性能表现
4. 学会根据系统特性选择合适的控制方法
5. 理解工程实践中的调试技巧和性能优化

**案例选择理由**：
- 🏠 **温度控制**：简单、直观、PID/MPC都有效 → 理解基本原理
- 🎯 **CartPole**：复杂、非线性、PID失效 → 理解高级方法的价值

---

## 6.1 房间温度控制：一阶系统 + PID + MPC实战

### 6.1.1 问题描述

**场景**：冬天室外温度5°C，需要将房间从5°C加热到22°C并保持。

**控制目标**：
- 快速达到目标温度（22°C）
- 保持温度稳定（±0.5°C）
- 节能（减少加热功率）
- 应对目标温度变化（22°C → 20°C）

**约束条件**：
- 加热器功率：0 ~ 2000W（不能制冷）
- 环境温度：5°C（恒定）

### 6.1.2 系统建模

#### 物理原理

**热平衡方程**：

$$C \frac{dT}{dt} = Q_{in} - Q_{loss}$$

其中：
- $C$：房间热容（J/°C）
- $T$：房间温度（°C）
- $Q_{in}$：加热器输入功率（W）
- $Q_{loss}$：热损失功率（W）

**热损失模型**（牛顿冷却定律）：

$$Q_{loss} = hA(T - T_{ambient})$$

其中：
- $h$：传热系数（W/(m²·°C)）
- $A$：散热面积（m²）
- $T_{ambient}$：环境温度（°C）

#### 标准化一阶模型

整理得：

$$\frac{dT}{dt} = -a(T - T_{ambient}) + bu$$

其中：
- $a = \frac{hA}{C}$：热损失系数（1/s）
- $b = \frac{1}{C}$：加热效率（°C/(W·s)）
- $u$：加热器功率（W）

**项目参数**（见 `MPCController/mpc_temperature_control.py`）：
```python
a = 0.05   # 热损失系数（良好隔热）
b = 0.002  # 加热效率
```

#### 传递函数形式

增量形式（$\Delta T = T - T_{ambient}$）：

$$G(s) = \frac{\Delta T(s)}{U(s)} = \frac{b}{s + a} = \frac{0.002}{s + 0.05}$$

**系统特性**：
- **时间常数**：$\tau = \frac{1}{a} = 20$s
- **增益**：$K = \frac{b}{a} = 0.04$ °C/W
- **调节时间**：$t_s \approx 4\tau = 80$s（进入2%误差带）

**物理意义**：
- 时间常数20s → 温度变化较慢
- 增益0.04 → 1000W功率提升40°C（从环境温度）

### 6.1.3 PID控制策略

#### 控制器设计

**PID控制律**：

$$u(t) = K_p e(t) + K_i \int e(\tau)d\tau + K_d \frac{de(t)}{dt}$$

其中：$e(t) = T_{setpoint} - T_{measured}$

**参数整定**（项目实现）：
```python
Kp = 100.0   # 比例增益
Ki = 1.0     # 积分增益
Kd = 500.0   # 微分增益
```

**整定理由**：
1. **Kp = 100**：
   - 误差1°C → 输出100W
   - 提供快速响应

2. **Ki = 1.0**：
   - 累积误差，消除稳态偏差
   - 较小值避免积分饱和

3. **Kd = 500**：
   - 阻尼作用，减小超调
   - 温度变化慢，噪声小，可用大Kd

#### 输出限幅

```python
pid_controller.set_output_limits(0, 2000)  # 功率约束
```

#### 性能预期

**优点**：
- ✅ 实现简单，无需模型
- ✅ 调参直观
- ✅ 鲁棒性好

**缺点**：
- ❌ 可能有超调
- ❌ 对setpoint变化反应慢
- ❌ 约束处理不优（简单截断）

### 6.1.4 MPC控制策略

#### 优化问题

**目标函数**：

$$\min_{u_0, \ldots, u_{M-1}} \sum_{i=0}^{N-1} Q(T_i - T_{ref})^2 + \sum_{i=0}^{M-1} Ru_i^2 + \Delta u \text{ penalty}$$

**约束**：
- 系统动力学：$T_{i+1} = T_i + [-a(T_i - T_{amb}) + bu_i] \cdot \Delta t$
- 功率约束：$0 \leq u_i \leq 2000$

**参数选择**（项目实现）：
```python
prediction_horizon = 20     # 预测200秒（3.3分钟）
control_horizon = 10        # 控制100秒
dt = 10.0                   # 采样周期10秒
Q_weight = 10.0            # 温度误差权重
R_weight = 0.001           # 控制代价权重
```

#### 参数设计理由

1. **预测时域 N=20**：
   - 预测未来200秒
   - 覆盖约10个时间常数
   - 足够"看清"温度演化趋势

2. **控制时域 M=10**：
   - 优化前100秒的控制
   - 减少计算量（相比M=20）
   - 后半段保持最后控制值

3. **Q_weight = 10.0**：
   - 中等温度误差惩罚
   - 平衡跟踪精度与控制平滑

4. **R_weight = 0.001**：
   - 小控制代价
   - 允许较大功率（快速加热）

#### MPC优势体现

1. **预测性**：
   - 提前"看到"温度将如何变化
   - 在目标改变前就开始调整

2. **约束处理**：
   - 功率限制直接在优化中考虑
   - 不是简单截断，而是最优利用

3. **平滑控制**：
   - $\Delta u$ 惩罚避免剧烈变化
   - 减少执行器磨损

### 6.1.5 实验结果与对比

**运行实验**：
```bash
python start.py mpc-temp
```

**结果图表**：`output/mpc_temperature_control.png`

#### 性能指标对比

| 指标 | MPC | PID | 说明 |
|------|-----|-----|------|
| **ISE**（积分平方误差） | 较小 | 较大 | MPC误差更小 |
| **IAE**（积分绝对误差） | 较小 | 较大 | MPC偏差更小 |
| **稳定时间** | 更快 | 稍慢 | MPC预测加速 |
| **超调量** | 几乎无 | 有小超调 | MPC优化避免 |
| **目标变化响应** | 提前调整 | 滞后反应 | MPC预测优势 |

#### 关键观察

**1. 初始加热阶段（0-15分钟）**：
- MPC：功率先大后逐渐减小，平滑接近目标
- PID：功率较大且持续时间长，有小超调

**2. 稳态维持（15-30分钟）**：
- MPC：功率围绕稳态值小幅波动
- PID：功率波动稍大

**3. 目标变化（30分钟，22°C→20°C）**：
- MPC：**提前**降低功率，平滑过渡
- PID：**滞后**反应，先降温后调整

#### 为什么MPC更好？

**场景**：设定温度从22°C降到20°C

**PID思维**：
```
当前温度 = 22°C
目标温度 = 20°C
误差 = -2°C
→ 减小/关闭加热
→ 等温度降下来
```

**MPC思维**：
```
当前温度 = 22°C
目标温度 = 20°C（刚改变）
预测：如果继续当前功率，温度会超过目标
→ 提前调整功率
→ 在未来某时刻正好到达20°C
→ 平滑过渡，无振荡
```

### 6.1.6 工程实践要点

#### 模型准确性

MPC性能依赖模型质量：
- ✅ 温度系统：模型简单、参数稳定 → MPC有效
- ⚠️ 如果$a, b$估计不准：性能下降但仍可用
- 💡 改进：在线辨识参数（自适应MPC）

#### 计算时延

**温度系统计算量评估**：
- 状态维度：1（温度）
- 控制维度：1（功率）
- 预测步数：20
- 优化变量：10（控制时域）

→ 求解时间：< 10ms（远小于采样周期10s）
→ ✅ 实时性完全满足

#### 参数调优技巧

**调整Q/R权重**：
```python
# 更重视跟踪 → 增大Q
Q_weight = 50.0   # 误差惩罚更重

# 更节能 → 增大R
R_weight = 0.1    # 控制代价更大

# 更平滑 → 增大Δu惩罚
```

**调整时域**：
```python
# 看得更远 → 增大N（但计算慢）
prediction_horizon = 30

# 快速响应 → 减小N
prediction_horizon = 10
```

### 6.1.7 本案例小结

**温度控制的特点**：
- ✅ 系统慢（时间常数20s）
- ✅ 模型简单（一阶）
- ✅ 约束清晰（功率限制）
- ✅ PID也有效

**MPC的价值**：
- 更优的动态性能（少超调）
- 更好的预见性（目标变化）
- 自然约束处理
- 但PID也足够好（工程选择要权衡）

**学习意义**：
- 理解MPC基本原理的最佳案例
- 直观展示"预测"的价值
- 为复杂系统（CartPole）打基础

---

## 6.2 CartPole倒立摆：高阶/非线性系统分析

### 6.2.1 问题描述

**CartPole倒立摆**：经典控制难题，也是强化学习的标准benchmark。

**物理系统**：
- 小车可左右移动（轨道±2.4m）
- 杆子通过铰链连接在小车上
- 目标：通过控制小车使杆子保持竖直

```
         │ ← 杆子（质量m，长度l）
         │
         ●  ← 铰链
      ┌─────┐
      │     │ ← 小车（质量M）
      └─────┘
    ═══════════ ← 轨道
     ←──→ 控制力F
```

**状态空间**（4维）：

$$x = \begin{bmatrix} x \\ \dot{x} \\ \theta \\ \dot{\theta} \end{bmatrix} = 
\begin{bmatrix} \text{小车位置} \\ \text{小车速度} \\ \text{杆角度} \\ \text{杆角速度} \end{bmatrix}$$

**控制目标**：
- 保持杆子竖直（$\theta = 0$）
- 保持小车在中心（$x = 0$）

**失败条件**：
- $|x| > 2.4$m（小车出界）
- $|\theta| > 12°$（杆子倒下）

### 6.2.2 系统动力学模型

#### 完整非线性模型

**拉格朗日力学推导**（项目实现见 `PIDController/cartpole_pid.py` 第100-112行）：

$$\begin{cases}
(M+m)\ddot{x} + ml\ddot{\theta}\cos\theta - ml\dot{\theta}^2\sin\theta = F \\
ml\ddot{x}\cos\theta + ml^2\ddot{\theta} = mgl\sin\theta
\end{cases}$$

**求解加速度**：

$$\ddot{x} = \frac{F + ml\dot{\theta}^2\sin\theta - ml\ddot{\theta}\cos\theta}{M+m}$$

$$\ddot{\theta} = \frac{(M+m)g\sin\theta - \cos\theta(F + ml\dot{\theta}^2\sin\theta)}{l(M+m-m\cos^2\theta)}$$

**系统参数**（项目默认）：
```python
M = 1.0    # 小车质量（kg）
m = 0.1    # 杆子质量（kg）
l = 0.5    # 杆子长度（m，到质心）
g = 9.8    # 重力加速度（m/s²）
```

#### 线性化模型（用于MPC）

**在平衡点线性化**（$\theta = 0, \dot{\theta} = 0$）：

$$\dot{x} = Ax + Bu$$

$$A = \begin{bmatrix} 
0 & 1 & 0 & 0 \\
0 & 0 & -\frac{mg}{M} & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & \frac{(M+m)g}{Ml} & 0
\end{bmatrix}, \quad
B = \begin{bmatrix} 0 \\ \frac{1}{M} \\ 0 \\ -\frac{1}{Ml} \end{bmatrix}$$

**特征值分析**：

系统有**不稳定极点**（正实部），说明开环系统不稳定→必须闭环控制！

### 6.2.3 PID控制策略

#### 策略1：单PID（仅控制角度）

**控制律**：

$$F = K_p \theta + K_i \int \theta dt + K_d \dot{\theta}$$

**参数**（项目实现）：
```python
Kp = 150.0   # 大比例增益
Ki = 0.5     # 小积分增益
Kd = 40.0    # 中等微分增益
```

**策略分析**：
- ✅ 简单直接
- ❌ 只关注角度，小车可能漂移
- ❌ 非线性效应强，PID线性假设失效

#### 策略2：级联PID（位置+角度）

**外环**（位置控制）：

$$\theta_{desired} = K_{p,pos} x + K_{d,pos} \dot{x}$$

**内环**（角度控制）：

$$F = K_{p,angle}(\theta - \theta_{desired}) + K_{d,angle}\dot{\theta}$$

**参数**：
```python
# 位置控制器
Kp_pos = 1.0
Kd_pos = 8.0

# 角度控制器
Kp_angle = 150.0
Kd_angle = 40.0
```

**策略分析**：
- ✅ 同时控制位置和角度
- ✅ 性能优于单PID
- ❌ 仍然难以长时间保持平衡

### 6.2.4 实验结果：PID的局限

**运行实验**：
```bash
python start.py cartpole
```

**结果图表**：`output/cartpole_pid_control.png`

#### 性能数据

| 策略 | 初始角度 | 存活时间 | 结果 |
|------|---------|---------|------|
| 单PID | 5.7° | 几秒 | 失败 |
| 单PID | 11.5° | <1秒 | 快速失败 |
| 级联PID | 5.7° | 几秒 | 失败 |
| 级联PID | 11.5° | <1秒 | 快速失败 |

#### 失败原因分析

**1. 非线性强烈**：
- $\sin\theta, \cos\theta$ 项
- $\dot{\theta}^2$ 项
- PID基于线性假设 → 大角度时模型错误严重

**2. 强耦合**：
- 位置和角度相互影响
- PID独立处理 → 协调困难

**3. 不稳定平衡点**：
- 开环不稳定
- PID响应慢 → 来不及纠正

**4. 约束处理差**：
- 控制力饱和（±100N）
- PID简单截断 → 性能下降

### 6.2.5 MPC控制策略

#### 线性MPC

**基于线性化模型**（见6.2.2）：

**优化问题**：

$$\min_{u_0, \ldots, u_{M-1}} \sum_{i=0}^{N-1} x_i^T Q x_i + \sum_{i=0}^{M-1} u_i^T R u_i$$

**权重矩阵**：
```python
Q = np.diag([10, 1, 200, 20])  # [位置, 速度, 角度, 角速度]
R = np.array([[0.01]])         # 控制代价
```

**参数理由**：
- $Q_{33} = 200$：角度最重要（保持竖直）
- $Q_{11} = 10$：位置次重要（保持中心）
- $Q_{22}, Q_{44}$ 较小：速度不直接惩罚
- $R = 0.01$：允许较大控制力

#### 非线性MPC

**使用完整非线性模型**：

每步求解：
```python
def cost_function(control_sequence, current_state):
    # 用非线性模型预测
    for i in range(N):
        next_state = nonlinear_dynamics(state, control)
        cost += state^T Q state + control^T R control
    return cost
```

**优势**：
- 更准确（尤其大角度）

**劣势**：
- 计算慢（非凸优化）
- 可能陷入局部最优

### 6.2.6 MPC vs PID 对比

**运行MPC实验**：
```bash
python start.py mpc
```

**结果图表**：`output/mpc_cartpole_comparison.png`

#### 性能对比

| 方法 | 存活时间 | 优势 | 劣势 |
|------|---------|------|------|
| **PID** | 0.10s | 简单 | 无法处理非线性 |
| **非线性MPC** | 3.15s | 预测能力强 | 计算量大 |
| **线性MPC** | 4.09s | 快速，效果好 | 仅适合小角度 |
| **自适应MPC** | 2.38s | 自适应 | 调节复杂 |

#### 关键发现

**1. MPC远优于PID**：
- 30-40倍存活时间
- PID几乎立刻失败，MPC能保持几秒

**2. 线性MPC效果最好**：
- 在小角度下，线性近似足够好
- 计算快（QP求解）
- 收敛性好

**3. 预测很重要**：
- $N=15$ 优于 $N=10$
- 看得更远 → 更好规划

**4. 仍未完全成功**：
- 最好也只保持4秒
- CartPole太难，需要更强方法（RL）

### 6.2.7 强化学习（RL）参考

**为什么RL适合CartPole？**

1. **无需模型**：
   - 通过试错学习最优策略
   - 不受建模误差影响

2. **处理非线性**：
   - 神经网络可表达复杂策略
   - 无线性假设

3. **长期优化**：
   - 最大化累积回报
   - 自然处理长时域

**典型RL方法**：
- **DQN**（Deep Q-Network）：离散动作
- **PPO**（Proximal Policy Optimization）：连续动作
- **SAC**（Soft Actor-Critic）：高效稳定

**RL vs MPC**：

| 对比项 | MPC | RL |
|--------|-----|-----|
| **模型需求** | 需要准确模型 | 无需模型 |
| **训练** | 无需训练 | 需要大量训练 |
| **泛化** | 限于相似系统 | 可泛化到变体 |
| **可解释性** | 高（优化过程清晰） | 低（黑盒策略） |
| **约束处理** | 自然（优化约束） | 困难（需设计） |
| **实时性** | 依赖计算能力 | 推理快（神经网络） |

**详细对比**：见 `doc/PID_vs_RL_对比.md`

### 6.2.8 本案例小结

**CartPole的特点**：
- ❌ 高维（4状态）
- ❌ 强非线性
- ❌ 不稳定平衡点
- ❌ 强耦合
- ⚠️ PID完全失效

**各方法表现**：
- **PID**：几乎无效（<0.2s）
- **MPC**：显著改善（2-4s），但仍有限
- **RL**：可长时间保持（理论上无限）

**工程启示**：
- 简单系统 → PID足够
- 中等复杂+有模型 → MPC
- 极端复杂/未知模型 → RL

---

## 6.3 复杂工业系统案例简介

虽然本项目未实现，但简要介绍典型工业应用。

### 6.3.1 化工过程控制

**蒸馏塔控制**：
- **状态**：塔顶/塔底温度、压力、液位
- **控制**：回流比、再沸器热量、进料流量
- **特点**：多变量、强耦合、大时滞
- **方法**：**MPC主导**（工业MPC诞生地）

**反应釜温度控制**：
- **状态**：温度、浓度、压力
- **控制**：冷却水流量、进料速度
- **特点**：非线性、放热反应
- **方法**：串级PID + 前馈补偿

### 6.3.2 电力系统

**汽轮机调速**：
- **状态**：转速、功率
- **控制**：蒸汽阀开度
- **特点**：大惯性、频繁扰动
- **方法**：PID + 增益调度

**电网频率控制**：
- **状态**：频率偏差、联络线功率
- **控制**：发电机出力
- **特点**：多区域协调、时变
- **方法**：分层控制（AGC）

### 6.3.3 机器人控制

**机械臂轨迹跟踪**：
- **状态**：关节角度、速度
- **控制**：关节力矩
- **特点**：多自由度、动力学耦合
- **方法**：
  - **计算力矩控制**（基于模型）
  - **MPC**（约束优化）
  - **自适应控制**（未知负载）

**移动机器人导航**：
- **状态**：位置、速度、姿态
- **控制**：轮速、转向
- **特点**：非完整约束、障碍避碰
- **方法**：**MPC**（处理约束路径规划）

### 6.3.4 汽车控制

**自适应巡航（ACC）**：
- **状态**：车速、车距、相对速度
- **控制**：油门、刹车
- **特点**：安全约束、舒适性
- **方法**：**MPC**（预测前车行为）

**车道保持（LKA）**：
- **状态**：横向偏差、航向角
- **控制**：方向盘转角
- **特点**：时变（曲率变化）
- **方法**：**MPC** + 视觉反馈

---

## 6.4 控制方法选型决策

### 6.4.1 决策流程图

```
┌─────────────────────────────────┐
│  控制系统需求分析                │
└────────────┬────────────────────┘
             │
             ▼
    ┌────────────────┐
    │ 系统复杂度？    │
    └───┬────────┬───┘
        │        │
   简单  │        │  复杂
        ▼        ▼
    ┌─────┐  ┌──────────┐
    │ PID │  │ 有模型？  │
    └─────┘  └─┬─────┬──┘
              有│     │无
                ▼     ▼
            ┌─────┐ ┌────┐
            │ MPC │ │ RL │
            └─────┘ └────┘
```

### 6.4.2 选型矩阵

| 系统特性 | PID推荐度 | MPC推荐度 | RL推荐度 |
|---------|----------|----------|----------|
| **SISO + 线性** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐ |
| **MIMO + 耦合** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **有准确模型** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **模型未知** | ⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ |
| **强约束** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **实时性要求高** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **快速部署** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐ |
| **极致性能** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

### 6.4.3 工程权衡

#### 成本考量

| 方法 | 开发成本 | 计算成本 | 维护成本 |
|------|---------|---------|---------|
| PID | 低 | 极低 | 低 |
| MPC | 中-高 | 中-高 | 中 |
| RL | 高 | 训练高/推理中 | 高 |

#### 风险评估

| 方法 | 稳定性风险 | 性能风险 | 安全风险 |
|------|-----------|---------|---------|
| PID | 低（经验丰富） | 中（受限系统） | 低 |
| MPC | 低-中（理论保证） | 低（优化最优） | 中（模型依赖） |
| RL | 高（黑盒） | 低（可达极致） | 高（难验证） |

---

## 6.5 本章总结与实践建议

### 6.5.1 核心要点回顾

**温度控制案例**：
- ✅ 一阶系统，模型简单
- ✅ PID有效，MPC更优
- ✅ MPC展现预测和约束优势
- 💡 理解MPC原理的最佳入门

**CartPole案例**：
- ❌ 高阶非线性，PID失效
- ✅ MPC显著改善（但仍有限）
- ✅ RL可达高性能（但训练成本高）
- 💡 理解高级方法价值的绝佳案例

### 6.5.2 学习路径建议

**Step 1：基础实验**
```bash
# 理解PID基本原理
python start.py demo

# 快速演示
python start.py quick
```

**Step 2：温度控制（MPC入门）**
```bash
# 运行MPC温度控制
python start.py mpc-temp

# 观察：预测、约束、平滑控制
```

**Step 3：CartPole（MPC进阶）**
```bash
# PID尝试（体会失败）
python start.py cartpole

# MPC对比（体会改善）
python start.py mpc
```

**Step 4：参数实验**
- 修改PID参数（`pid_controller.py`）
- 修改MPC参数（`mpc_controller.py`）
- 观察性能变化

### 6.5.3 实践技巧

**调试PID**：
1. 先P后I再D
2. 观察响应曲线
3. 记录参数效果
4. 注意积分饱和

**调试MPC**：
1. 先验证模型
2. 从小N开始
3. 调Q/R权重
4. 检查约束可行性
5. 监控计算时间

**对比测试**：
1. 统一性能指标（ISE、IAE等）
2. 多种初始条件
3. 加入扰动测试
4. 记录失败模式

### 6.5.4 拓展方向

**深入PID**：
- 抗饱和算法
- 自整定PID
- 增益调度

**深入MPC**：
- 经济MPC（优化成本函数）
- 鲁棒MPC（不确定性）
- 学习型MPC（数据驱动模型）

**探索RL**：
- 实现DQN/PPO
- MPC+RL混合
- 迁移学习

---

## 6.6 项目代码对应

| 案例内容 | 文件/命令 |
|---------|----------|
| **温度系统模型** | `MPCController/mpc_temperature_control.py` 第44-119行 |
| **温度PID控制** | `MPCController/mpc_temperature_control.py` 第354-403行 |
| **温度MPC控制** | `MPCController/mpc_temperature_control.py` 第149-269行 |
| **温度实验运行** | `python start.py mpc-temp` |
| **温度结果图** | `output/mpc_temperature_control.png` |
| **CartPole模型** | `PIDController/cartpole_pid.py` 第36-143行 |
| **CartPole PID** | `PIDController/cartpole_pid.py` 第145-206行 |
| **CartPole实验** | `python start.py cartpole` |
| **CartPole结果** | `output/cartpole_pid_control.png` |
| **MPC控制器** | `MPCController/mpc_controller.py` |
| **MPC实验运行** | `python start.py mpc` |
| **MPC结果图** | `output/mpc_cartpole_comparison.png` |
| **PID详细实验** | `PIDController/pid_experiments.py` |
| **实验报告** | `doc/实验报告.md` |

---

## 📚 扩展阅读

**温度控制**：
- 建筑能耗优化
- HVAC系统控制
- 工业炉温控制

**倒立摆**：
- Segway平衡车
- 火箭着陆控制
- 双足机器人平衡

**MPC应用**：
- Camacho & Bordons, "Model Predictive Control"
- 石油化工中的MPC（DMC、RMPCT）

**RL应用**：
- Sutton & Barto, "Reinforcement Learning"
- OpenAI Gym环境
- Stable-Baselines3库

---

> **导航**: [返回课程大纲](../CONTROL_ENGINEERING_OUTLINE.md) | [上一章：先进控制方法](第5章_先进控制方法入门.md)

---

**最后更新**: 2025年10月30日  
**作者**: Control Engineering Lab

